{"ast":null,"code":"module.exports = LRUCache; // This will be a proper iterable 'Map' in engines that support it,\n// or a fakey-fake PseudoMap in older versions.\n\nvar Map = require('pseudomap');\n\nfunction naiveLength() {\n  return 1;\n}\n\nfunction LRUCache(options) {\n  if (!(this instanceof LRUCache)) return new LRUCache(options);\n  if (typeof options === 'number') options = {\n    max: options\n  };\n  if (!options) options = {};\n  this._max = options.max; // Kind of weird to have a default max of Infinity, but oh well.\n\n  if (!this._max || !(typeof this._max === \"number\") || this._max <= 0) this._max = Infinity;\n  this._lengthCalculator = options.length || naiveLength;\n  if (typeof this._lengthCalculator !== \"function\") this._lengthCalculator = naiveLength;\n  this._allowStale = options.stale || false;\n  this._maxAge = options.maxAge || null;\n  this._dispose = options.dispose;\n  this.reset();\n} // resize the cache when the max changes.\n\n\nObject.defineProperty(LRUCache.prototype, \"max\", {\n  set: function set(mL) {\n    if (!mL || !(typeof mL === \"number\") || mL <= 0) mL = Infinity;\n    this._max = mL;\n    if (this._length > this._max) trim(this);\n  },\n  get: function get() {\n    return this._max;\n  },\n  enumerable: true\n}); // resize the cache when the lengthCalculator changes.\n\nObject.defineProperty(LRUCache.prototype, \"lengthCalculator\", {\n  set: function set(lC) {\n    if (typeof lC !== \"function\") {\n      this._lengthCalculator = naiveLength;\n      this._length = this._lruList.size;\n\n      this._cache.forEach(function (value, key) {\n        value.length = 1;\n      });\n    } else {\n      this._lengthCalculator = lC;\n      this._length = 0;\n\n      this._cache.forEach(function (value, key) {\n        value.length = this._lengthCalculator(value.value, key);\n        this._length += value.length;\n      }, this);\n    }\n\n    if (this._length > this._max) trim(this);\n  },\n  get: function get() {\n    return this._lengthCalculator;\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, \"length\", {\n  get: function get() {\n    return this._length;\n  },\n  enumerable: true\n});\nObject.defineProperty(LRUCache.prototype, \"itemCount\", {\n  get: function get() {\n    return this._lruList.size;\n  },\n  enumerable: true\n});\n\nfunction reverseKeys(map) {\n  // keys live in lruList map in insertion order.\n  // we want them in reverse insertion order.\n  // flip the list of keys.\n  var itemCount = map.size;\n  var keys = new Array(itemCount);\n  var i = itemCount;\n  map.forEach(function (value, key) {\n    keys[--i] = key;\n  });\n  return keys;\n}\n\nLRUCache.prototype.rforEach = function (fn, thisp) {\n  thisp = thisp || this;\n\n  this._lruList.forEach(function (hit) {\n    forEachStep(this, fn, hit, thisp);\n  }, this);\n};\n\nfunction forEachStep(self, fn, hit, thisp) {\n  if (isStale(self, hit)) {\n    del(self, hit);\n\n    if (!self._allowStale) {\n      hit = undefined;\n    }\n  }\n\n  if (hit) {\n    fn.call(thisp, hit.value, hit.key, self);\n  }\n}\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this;\n  var keys = reverseKeys(this._lruList);\n\n  for (var k = 0; k < keys.length; k++) {\n    var hit = this._lruList.get(keys[k]);\n\n    forEachStep(this, fn, hit, thisp);\n  }\n};\n\nLRUCache.prototype.keys = function () {\n  return reverseKeys(this._lruList).map(function (k) {\n    return this._lruList.get(k).key;\n  }, this);\n};\n\nLRUCache.prototype.values = function () {\n  return reverseKeys(this._lruList).map(function (k) {\n    return this._lruList.get(k).value;\n  }, this);\n};\n\nLRUCache.prototype.reset = function () {\n  if (this._dispose && this._cache) {\n    this._cache.forEach(function (entry, key) {\n      this._dispose(key, entry.value);\n    }, this);\n  }\n\n  this._cache = new Map(); // hash of items by key\n\n  this._lruList = new Map(); // list of items in order of use recency\n\n  this._mru = 0; // most recently used\n\n  this._lru = 0; // least recently used\n\n  this._length = 0; // number of items in the list\n};\n\nLRUCache.prototype.dump = function () {\n  var arr = [];\n  var i = 0;\n  var size = this._lruList.size;\n  return reverseKeys(this._lruList).map(function (k) {\n    var hit = this._lruList.get(k);\n\n    if (!isStale(this, hit)) {\n      return {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      };\n    }\n  }, this).filter(function (h) {\n    return h;\n  });\n};\n\nLRUCache.prototype.dumpLru = function () {\n  return this._lruList;\n};\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || this._maxAge;\n  var now = maxAge ? Date.now() : 0;\n\n  var len = this._lengthCalculator(value, key);\n\n  if (this._cache.has(key)) {\n    if (len > this._max) {\n      del(this, this._cache.get(key));\n      return false;\n    }\n\n    var item = this._cache.get(key); // dispose of the old one before overwriting\n\n\n    if (this._dispose) this._dispose(key, item.value);\n    item.now = now;\n    item.maxAge = maxAge;\n    item.value = value;\n    this._length += len - item.length;\n    item.length = len;\n    this.get(key);\n    if (this._length > this._max) trim(this);\n    return true;\n  }\n\n  var hit = new Entry(key, value, this._mru, len, now, maxAge);\n  incMru(this); // oversized objects fall out of cache automatically.\n\n  if (hit.length > this._max) {\n    if (this._dispose) this._dispose(key, value);\n    return false;\n  }\n\n  this._length += hit.length;\n\n  this._cache.set(key, hit);\n\n  this._lruList.set(hit.lu, hit);\n\n  if (this._length > this._max) trim(this);\n  return true;\n};\n\nLRUCache.prototype.has = function (key) {\n  if (!this._cache.has(key)) return false;\n\n  var hit = this._cache.get(key);\n\n  if (isStale(this, hit)) {\n    return false;\n  }\n\n  return true;\n};\n\nLRUCache.prototype.get = function (key) {\n  return get(this, key, true);\n};\n\nLRUCache.prototype.peek = function (key) {\n  return get(this, key, false);\n};\n\nLRUCache.prototype.pop = function () {\n  var hit = this._lruList.get(this._lru);\n\n  del(this, hit);\n  return hit || null;\n};\n\nLRUCache.prototype.del = function (key) {\n  del(this, this._cache.get(key));\n};\n\nLRUCache.prototype.load = function (arr) {\n  //reset the cache\n  this.reset();\n  var now = Date.now(); // A previous serialized cache has the most recent items first\n\n  for (var l = arr.length - 1; l >= 0; l--) {\n    var hit = arr[l];\n    var expiresAt = hit.e || 0;\n\n    if (expiresAt === 0) {\n      // the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v);\n    } else {\n      var maxAge = expiresAt - now; // dont add already expired items\n\n      if (maxAge > 0) {\n        this.set(hit.k, hit.v, maxAge);\n      }\n    }\n  }\n};\n\nfunction get(self, key, doUse) {\n  var hit = self._cache.get(key);\n\n  if (hit) {\n    if (isStale(self, hit)) {\n      del(self, hit);\n      if (!self._allowStale) hit = undefined;\n    } else {\n      if (doUse) use(self, hit);\n    }\n\n    if (hit) hit = hit.value;\n  }\n\n  return hit;\n}\n\nfunction isStale(self, hit) {\n  if (!hit || !hit.maxAge && !self._maxAge) return false;\n  var stale = false;\n  var diff = Date.now() - hit.now;\n\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge;\n  } else {\n    stale = self._maxAge && diff > self._maxAge;\n  }\n\n  return stale;\n}\n\nfunction use(self, hit) {\n  shiftLU(self, hit);\n  hit.lu = self._mru;\n  incMru(self);\n\n  self._lruList.set(hit.lu, hit);\n}\n\nfunction trim(self) {\n  if (self._length > self._max) {\n    var keys = reverseKeys(self._lruList);\n\n    for (var k = keys.length - 1; self._length > self._max; k--) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      self._lru = keys[k - 1];\n      del(self, self._lruList.get(keys[k]));\n    }\n  }\n}\n\nfunction shiftLU(self, hit) {\n  self._lruList.delete(hit.lu);\n\n  if (hit.lu === self._lru) self._lru = reverseKeys(self._lruList).pop();\n}\n\nfunction del(self, hit) {\n  if (hit) {\n    if (self._dispose) self._dispose(hit.key, hit.value);\n    self._length -= hit.length;\n\n    self._cache.delete(hit.key);\n\n    shiftLU(self, hit);\n  }\n} // classy, since V8 prefers predictable objects.\n\n\nfunction Entry(key, value, lu, length, now, maxAge) {\n  this.key = key;\n  this.value = value;\n  this.lu = lu;\n  this.length = length;\n  this.now = now;\n  if (maxAge) this.maxAge = maxAge;\n} // Incrementers and decrementers that loop at MAX_SAFE_INTEGER\n// only relevant for the lu, lru, and mru counters, since they\n// get touched a lot and can get very large. Also, since they\n// only go upwards, and the sets will tend to be much smaller than\n// the max, we can very well assume that a very small number comes\n// after a very large number, rather than before it.\n\n\nvar maxSafeInt = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nfunction intInc(number) {\n  return number === maxSafeInt ? 0 : number + 1;\n}\n\nfunction incMru(self) {\n  do {\n    self._mru = intInc(self._mru);\n  } while (self._lruList.has(self._mru));\n}","map":null,"metadata":{},"sourceType":"script"}