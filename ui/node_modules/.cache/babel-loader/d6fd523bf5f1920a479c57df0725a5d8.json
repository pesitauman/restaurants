{"ast":null,"code":"/* globals define */\n(function (root, factory) {\n  'use strict';\n  /* istanbul ignore next:cant test */\n\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else {\n    // Browser globals\n    root.objectPath = factory();\n  }\n})(this, function () {\n  'use strict';\n\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function isEmpty(value) {\n    if (!value) {\n      return true;\n    }\n\n    if (isArray(value) && value.length === 0) {\n      return true;\n    } else if (!isString(value)) {\n      for (var i in value) {\n        if (_hasOwnProperty.call(value, i)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function isNumber(value) {\n    return typeof value === 'number';\n  }\n\n  function isString(obj) {\n    return typeof obj === 'string';\n  }\n\n  function isArray(obj) {\n    return Array.isArray(obj);\n  }\n\n  function getKey(key) {\n    var intKey = parseInt(key);\n\n    if (intKey.toString() === key) {\n      return intKey;\n    }\n\n    return key;\n  }\n\n  var objectPathImmutable = function objectPathImmutable(src) {\n    var dest = src;\n    var committed = false;\n    var transaction = Object.keys(api).reduce(function (proxy, prop) {\n      /* istanbul ignore else */\n      if (typeof api[prop] === 'function') {\n        proxy[prop] = function () {\n          var args = [dest, src].concat(Array.prototype.slice.call(arguments));\n\n          if (committed) {\n            throw new Error('Cannot call ' + prop + ' after `value`');\n          }\n\n          dest = api[prop].apply(null, args);\n          return transaction;\n        };\n      }\n\n      return proxy;\n    }, {});\n\n    transaction.value = function () {\n      committed = true;\n      return dest;\n    };\n\n    return transaction;\n  };\n\n  function clone(obj, createIfEmpty, assumeArray) {\n    if (obj == null) {\n      if (createIfEmpty) {\n        if (assumeArray) {\n          return [];\n        }\n\n        return {};\n      }\n\n      return obj;\n    } else if (isArray(obj)) {\n      return obj.slice();\n    }\n\n    var res = {};\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        res[key] = obj[key];\n      }\n    }\n\n    return res;\n  }\n\n  function changeImmutable(dest, src, path, changeCallback) {\n    if (isNumber(path)) {\n      path = [path];\n    }\n\n    if (isEmpty(path)) {\n      return src;\n    }\n\n    if (isString(path)) {\n      return changeImmutable(dest, src, path.split('.').map(getKey), changeCallback);\n    }\n\n    var currentPath = path[0];\n\n    if (!dest || dest === src) {\n      dest = clone(src, true, isNumber(currentPath));\n    }\n\n    if (path.length === 1) {\n      return changeCallback(dest, currentPath);\n    }\n\n    if (src != null) {\n      src = src[currentPath];\n    }\n\n    dest[currentPath] = changeImmutable(dest[currentPath], src, path.slice(1), changeCallback);\n    return dest;\n  }\n\n  var api = {};\n\n  api.set = function set(dest, src, path, value) {\n    return changeImmutable(dest, src, path, function (clonedObj, finalPath) {\n      clonedObj[finalPath] = value;\n      return clonedObj;\n    });\n  };\n\n  api.update = function update(dest, src, path, updater) {\n    return changeImmutable(dest, src, path, function (clonedObj, finalPath) {\n      clonedObj[finalPath] = updater(clonedObj[finalPath]);\n      return clonedObj;\n    });\n  };\n\n  api.push = function push(dest, src, path\n  /*, values */\n  ) {\n    var values = Array.prototype.slice.call(arguments, 3);\n    return changeImmutable(dest, src, path, function (clonedObj, finalPath) {\n      if (!isArray(clonedObj[finalPath])) {\n        clonedObj[finalPath] = values;\n      } else {\n        clonedObj[finalPath] = clonedObj[finalPath].concat(values);\n      }\n\n      return clonedObj;\n    });\n  };\n\n  api.insert = function insert(dest, src, path, value, at) {\n    at = ~~at;\n    return changeImmutable(dest, src, path, function (clonedObj, finalPath) {\n      var arr = clonedObj[finalPath];\n\n      if (!isArray(arr)) {\n        if (arr != null && typeof arr !== 'undefined') {\n          throw new Error('Expected ' + path + 'to be an array. Instead got ' + typeof path);\n        }\n\n        arr = [];\n      }\n\n      var first = arr.slice(0, at);\n      first.push(value);\n      clonedObj[finalPath] = first.concat(arr.slice(at));\n      return clonedObj;\n    });\n  };\n\n  api.del = function del(dest, src, path, value, at) {\n    return changeImmutable(dest, src, path, function (clonedObj, finalPath) {\n      if (Array.isArray(clonedObj)) {\n        if (clonedObj[finalPath] !== undefined) {\n          clonedObj.splice(finalPath, 1);\n        }\n      } else {\n        if (clonedObj.hasOwnProperty(finalPath)) {\n          delete clonedObj[finalPath];\n        }\n      }\n\n      return clonedObj;\n    });\n  };\n\n  api.assign = function assign(dest, src, path, source) {\n    return changeImmutable(dest, src, path, function (clonedObj, finalPath) {\n      source = Object(source);\n      var target = clone(clonedObj[finalPath], true);\n\n      for (var key in source) {\n        if (_hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n\n      clonedObj[finalPath] = target;\n      return clonedObj;\n    });\n  };\n\n  return Object.keys(api).reduce(function (objectPathImmutable, method) {\n    objectPathImmutable[method] = api[method].bind(null, null);\n    return objectPathImmutable;\n  }, objectPathImmutable);\n});","map":null,"metadata":{},"sourceType":"script"}